#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
/*Temps Réel en multi-coeurs: problème de contention mémoire*/
\end_layout

\begin_layout Date
02 Mars 2013
\end_layout

\begin_layout Author
Louisa BESSAD & Roberto MEDINA
\end_layout

\begin_layout Standard
??? Présenter les sructures de PAPI used ???
\end_layout

\begin_layout Section*
Objectifs
\end_layout

\begin_layout Enumerate
Mesures:
\end_layout

\begin_deeper
\begin_layout Enumerate
Plateforme de mesures avec la librairie PAPI (sur les caches L1/L2, L3 si
 présent, accès mémoire)
\end_layout

\begin_layout Enumerate
Clouer les tâches sur les différents coeurs pour ne pas mettre d'autres
 tâches sur ces coeurs -> priorité maximale
\end_layout

\end_deeper
\begin_layout Enumerate
Développer une application qui soit faussement Temps-Réel (temps d'exécution
 fini), paramétrables si besoin (ajout d'un temporisateur), qui accède à
 tous les caches et à la mémoire
\end_layout

\begin_deeper
\begin_layout Enumerate
prévoir le prefetch du processeur
\end_layout

\begin_layout Enumerate
optimisation du compilateur (accès séquentiel préféré par ex)
\end_layout

\end_deeper
\begin_layout Enumerate
Développer une appplication attaquante qui soit la plus gourmande en accès
 mémoire possible
\end_layout

\begin_layout Enumerate
Mesurer le temps d'exécution de la TR seule puis quand on ajoute 1 à N attaquant
s
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Utiliser GNUPLOT histogramme pour représenter nos résultats
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Avancée
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Modification tâche temps-réel pour pouvoir ajouter un temporisateur par
 la suite.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Idée de taches attaquante occupant au maximum le bus et les caches:
\end_layout

\begin_layout Itemize
open et close successif :
\end_layout

\begin_deeper
\begin_layout Itemize
(bloc pris en tête de liste bloc libre et puis libéré et donc mis en queue
 de cette même liste -> sollicite des zones mémoires différentes et donc
 des places dans le cache différentes).
\end_layout

\begin_layout Itemize
pas open séquentiels car ramène plusieurs blocs lors du premier open et
 les autres prendraient ces blocs là plutôt que retourner sur le disque
 en chercher d'autres.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
read -> pas accès méoire obg -> NON
\end_layout

\begin_layout Itemize
write -> accès mémoire obg si on close juste après pour éviter l'utilisation
 du write back si il y a (et donc obliger l'accès disque).
\end_layout

\begin_layout Itemize

\emph on
déplacement pointeur -> accède uniquement à la table des fichiers ouverts
 pour modifier un pointeur il n'y a donc pas d'accès disque et donc d'occupation
 du bus -> NON
\end_layout

\begin_layout Itemize

\emph on
dupplication -> n'alloue pas d'autres bloc mais accès mémoire obg pour rajouter
 un pointeur dans la table des fichiers ouverts, mais n'accède pas au disque(non
 swapable) -> NON
\end_layout

\begin_layout Itemize

\emph on
copie d'un fichier vers autre???? NON car chargement séquentiel des contenus
 en cache.
\end_layout

\begin_layout Itemize
open, write, dupplication, lseek, close, read sur autre desc puis close.
\end_layout

\begin_layout Standard
write >> open en temps d'accès / write ~ dupplication
\end_layout

\begin_layout Subsection*
Implémentations choisies:
\end_layout

\begin_layout Itemize
open, write, close en boucle
\end_layout

\begin_layout Itemize
open, read jusqu'à fin de fichier puis retour au début tant que le nombre
 d'itérations désirés n'est pas atteint, close
\end_layout

\begin_layout Standard
A effectuer dans cet ordre pour faire les tests.
\end_layout

\begin_layout Section*
Questions / A faire:
\end_layout

\begin_layout Standard
tester quel type de tâche attaquante est la plus gourmande.
\end_layout

\end_body
\end_document
