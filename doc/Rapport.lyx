#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Temps-réel en multi-cœurs : problème de la contention mémoire
\end_layout

\begin_layout Author
Louisa BESSAD & Roberto MEDINA
\end_layout

\begin_layout Chapter
Problème de conccurence d'accès
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Itemize
Description du sujet
\end_layout

\begin_layout Itemize
Problématique: géstion de l'accès concurrent aux caches et à la mémoire
 entre une tâche temps-réel et des tâches attaquantes en sachant qu'on ne
 peut faire que des mesures globales dans la mémoire et pas pour chaque
 coeur
\end_layout

\begin_layout Itemize
Objectif: proposer une solution en mode user en utilisant une librairie
 particulière (PAPI) pour les mesures
\end_layout

\begin_layout Itemize
Description de l'architecture: intel Core I3-330M Processor(2.13GHz, 3MB
 L3 Cache), approximation des accès mémoire par les MISS sur le L3 + schéma
 de la différence entre les machines qui ont fait les tests.
\end_layout

\begin_layout Section
Les différentes tâches (attaquantes, temps réel)
\end_layout

\begin_layout Itemize
Description des 2 types de tâches et leur impact sur la mémoire:
\end_layout

\begin_deeper
\begin_layout Itemize
on a une tâche temps-réelle non périodique et sans contrainte temporelle,
 on doit uniquement être sûre qu'elle se termine en un temps fini
\end_layout

\begin_layout Itemize
les tâches attaquantes doivent effectuer un maximum d'accès mémorie afin
 de saturer le bus mémoire et les caches partagés entre les différents coeurs
\end_layout

\end_deeper
\begin_layout Itemize
Evolution des choix face au prefetching, régime transitoire et permanent,
 les printf
\end_layout

\begin_layout Section
Comment mesurer?
\end_layout

\begin_layout Itemize
Utilisation de PAPI (fonction pour les mesures, évèments initialisés et
 utilisés)
\end_layout

\begin_layout Itemize
Mesures du nombre de MISS sur le cache partagé L3 pour approximer le nombre
 d'accès mémoire puisqu'on ne peut mesurer les accès mémoire sur notre machine
\end_layout

\begin_layout Itemize
Fonctionnement du wrapper
\end_layout

\begin_layout Section
Résultats et analyse des courbes
\end_layout

\begin_layout Itemize
Evolution des résultats avec les évolutions de code, en fonction du gouverneur
 du CPU (si on teste sur plusieurs machines), 2 attaquants au lieu de 3
 (garder un coeur pour l'OS), désactivation de l'hyperviseur (pas d'autres
 scheduler sur les coeurs utilisés)
\end_layout

\begin_layout Itemize
Différences des résultats avec pré-fecthing
\end_layout

\begin_layout Itemize
Résultats sur le temps d'exécution ou le nombre d'octets lu pendant la période
 de mesures par chaque coeur (C1 puis C1 & 2 puis C1,2 & 3)
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Itemize
conclure sur le problème d'accès mémoire à une tâche temps-réel face à des
 attaquants
\end_layout

\begin_layout Itemize
ouvrir sur une solution en mode user qui sera la sous-réservation de BP
 mémoire
\end_layout

\begin_layout Chapter
Problème de la sous-réservation de BP mémoire:
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Itemize
Explication du problème de sous-réservation de BP mémoire
\end_layout

\begin_layout Itemize
Les problèmes que cette solution peut générer: comment gérer les accès mémoire
 tout en gardant une certaine concurrence
\end_layout

\begin_layout Itemize
Une solution proposée: Création d'un hyperviseur envoyant des signaux aux
 différentes tâches lorqu'elles ont consommées toute la BP accordé et que
 la tâche temps-réel n'a pas encore utilisé sa BP et remise à zéros des
 différents compteurs de BP dans ce cas
\end_layout

\begin_layout Section
L'hyperviseur, la tâche temps-réel et les tâches attaquantes
\end_layout

\begin_layout Itemize
Evolution du fonctionnement de la tâche temps-réel et des tâches attaquantes
 face à l'insertion de l'envoi de signaux
\end_layout

\begin_layout Itemize
Description du fonctionnement de l'hyperviseur (mesure de la consommation
 de BP, gestion des compteurs mesurant cette consommation et envoie de signaux
 aux différentes tâches), problèmes rencontrés ou pas
\end_layout

\begin_layout Itemize
Comment utiliser PAPI dans cette situation (fonctionnalitées rajoutées)
\end_layout

\begin_layout Section
Mesures, résultats et analyse
\end_layout

\begin_layout Itemize
Changement de la méthode de mesure
\end_layout

\begin_layout Itemize
analyse des courbes obtenues avec la solution proposée
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Itemize
La solution résout-elle le problème de contention mémoire, si oui pourquoi?
\end_layout

\begin_layout Chapter
Conclusion face au sujet proposé:
\end_layout

\begin_layout Itemize
Avantages et inconvénients de l'utilisation d'un hyperviseur et comparaison
 avec la première partie
\end_layout

\begin_layout Itemize
Ouverture: Existe-t-il une solution plus optimale?
\end_layout

\end_body
\end_document
